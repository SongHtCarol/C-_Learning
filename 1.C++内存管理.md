 三种内存分配

变量的存储类型 **(storage class)** 是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保存多久等。

- **静态存储区**
    在编译时给分配固定的内存空间，`在执行时赋值`。
    `static/extern`关键字修饰的变量被分配在静态存储区，代码也存在静态存储区，程序结束后由系统释放。`extern修饰的变量就是所说的全局变量`。
    `static`关键字：
    当它用于函数定义或者用于代码块之外的变量声明时，`static`关键字用于修改标识符的连接属性，从`external`改为`internal`，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明他们的源文件中访问。
    当它作用于代码内部的变量声明时，`static`关键字用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。用这种方式声明的变量在程序执行之前创建，并在程序的整个执行期间一直存在。当所在的函数被多次调用时，`static`类型的变量从第二次起不会被初始化。
    `static`表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。
    `static`静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部。
    `static`成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有`this`指针，这导致：
        1、不能直接存取类的非静态成员变量，调用非静态成员函数
        2、不能被声明为`virtual`

- **栈：动态存储区**
    在运行时分配固定的内存空间。
    虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个"大小多少"是在编译时确定的,不是在运行时.

- **堆：动态存储区**
    在运行时分配可变的内存空间，由操作系统完成。
    由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低。但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。多态变量所需的存储空间只有在运行时创建了对象之后才能确定。在C++中，要求创建一个对象时，只需用new命令编制相关的代码即可。

    **关于alloc**
    ```C
    calloc() 
    void* calloc (size_t num, size_t size);
    函数用来动态地分配内存空间并初始化为 0。
    ```
    ```C
    malloc() 
    void* malloc (size_t size);
    函数用来动态地分配内存空间,不做初始化,里边数据是未知的垃圾数据。
    ```
    ```C
    realloc() 
    void * realloc(void * p,int n);
    重新分配堆上的void指针p所指的空间为n个字节，同时会复制原有内容到新分配的堆上存储空间。注意，若原来的void指针p在堆上的空间不大于n个字节，则保持不变。
    ```
    ```C
    memset() 
    void * memset (void * p, int c, int n) ;
    对于void指针p为首地址的n个字节，将其中的每个字节设置为c。
    ```
    **malloc 和 new 的区别**
    
    a. new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区可以是堆，也可以是静态区，具体是什么要看对象是哪种类型。
    
    
    
    b. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
    

    
    c. new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。
    

    
    d. 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
    

    
    e.  使用new操作符来分配对象内存时会经历三个步骤：
        第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
        第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
        第三步：对象构造完成后，返回一个指向该对象的指针。
        使用delete操作符来释放对象内存时会经历两个步骤：
        第一步：调用对象的析构函数。
        第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。
    
    
    
    f.使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。
    new没有这样直观的配套设施来扩充内存。
    
    
    g. 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler,指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler.set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。
    对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。
    

